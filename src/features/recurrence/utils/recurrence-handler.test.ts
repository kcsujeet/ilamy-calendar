import { describe, expect, it } from 'bun:test'
import { RRule } from 'rrule'
import type { CalendarEvent } from '@/components/types'
import dayjs from '@/lib/configs/dayjs-config'
import {
	deleteRecurringEvent,
	generateRecurringEvents,
	updateRecurringEvent,
} from './recurrence-handler'

const createBaseRecurringEvent = (
	overrides: Partial<CalendarEvent> = {}
): CalendarEvent => ({
	id: 'event-1',
	title: 'Weekly Sync',
	start: dayjs('2025-01-06T10:00:00.000Z'),
	end: dayjs('2025-01-06T11:00:00.000Z'),
	rrule: {
		freq: RRule.WEEKLY,
		interval: 1,
		dtstart: new Date('2025-01-06T10:00:00.000Z'),
	},
	...overrides,
})

describe('recurrence-handler utility tests', () => {
	describe('deleteRecurringEvent', () => {
		it('should delete entire series (scope: all) when uid is missing from base event', () => {
			const baseEvent = createBaseRecurringEvent({ id: 'series-1' })
			// Instance generated by the engine would have a generated UID
			const targetInstance: CalendarEvent = {
				...baseEvent,
				id: 'series-1_1',
				start: baseEvent.start.add(1, 'week'),
				end: baseEvent.end.add(1, 'week'),
				uid: 'series-1@ilamy.calendar',
				rrule: undefined,
			}

			const currentEvents = [baseEvent]
			const result = deleteRecurringEvent({
				targetEvent: targetInstance,
				currentEvents,
				scope: 'all',
			})

			expect(result).toHaveLength(0)
		})

		it('should delete entire series (scope: all) when uid is explicitly set', () => {
			const baseEvent = createBaseRecurringEvent({
				id: 'series-2',
				uid: 'custom-uid',
			})
			const targetInstance: CalendarEvent = {
				...baseEvent,
				id: 'series-2_1',
				start: baseEvent.start.add(1, 'week'),
				end: baseEvent.end.add(1, 'week'),
				uid: 'custom-uid',
				rrule: undefined,
			}

			const currentEvents = [baseEvent]
			const result = deleteRecurringEvent({
				targetEvent: targetInstance,
				currentEvents,
				scope: 'all',
			})

			expect(result).toHaveLength(0)
		})

		it('should only delete this instance (scope: this) and update exdates', () => {
			const baseEvent = createBaseRecurringEvent({ id: 'series-3' })
			const targetInstance: CalendarEvent = {
				...baseEvent,
				id: 'series-3_1',
				start: baseEvent.start.add(1, 'week'),
				end: baseEvent.end.add(1, 'week'),
				uid: 'series-3@ilamy.calendar',
				rrule: undefined,
			}

			const currentEvents = [baseEvent]
			const result = deleteRecurringEvent({
				targetEvent: targetInstance,
				currentEvents,
				scope: 'this',
			})

			expect(result).toHaveLength(1)
			expect(result[0].exdates).toContain(targetInstance.start.toISOString())
		})
	})

	describe('updateRecurringEvent', () => {
		it('should update entire series (scope: all) when uid is missing', () => {
			const baseEvent = createBaseRecurringEvent({ id: 'series-4' })
			const targetInstance: CalendarEvent = {
				...baseEvent,
				id: 'series-4_1',
				start: baseEvent.start.add(1, 'week'),
				end: baseEvent.end.add(1, 'week'),
				uid: 'series-4@ilamy.calendar',
				rrule: undefined,
			}

			const currentEvents = [baseEvent]
			const result = updateRecurringEvent({
				targetEvent: targetInstance,
				updates: { title: 'New Title' },
				currentEvents,
				scope: 'all',
			})

			expect(result).toHaveLength(1)
			expect(result[0].title).toBe('New Title')
		})
	})

	describe('generateRecurringEvents', () => {
		it('should respect overrides when uid is missing from base but present in override', () => {
			const baseEvent = createBaseRecurringEvent({ id: 'series-5' })
			const overrideDate = baseEvent.start.add(1, 'week')
			const overrideEvent: CalendarEvent = {
				...baseEvent,
				id: 'series-5_override',
				start: overrideDate,
				end: overrideDate.add(1, 'hour'),
				title: 'Overridden Title',
				uid: 'series-5@ilamy.calendar',
				recurrenceId: overrideDate.toISOString(),
			}

			const currentEvents = [baseEvent, overrideEvent]
			const generated = generateRecurringEvents({
				event: baseEvent,
				currentEvents,
				startDate: baseEvent.start.subtract(1, 'day'),
				endDate: baseEvent.start.add(1, 'month'),
			})

			const overridden = generated.find((e) => e.start.isSame(overrideDate))
			expect(overridden?.title).toBe('Overridden Title')
		})
	})
})
